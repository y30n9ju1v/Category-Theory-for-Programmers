# Bartosz Milewski's Programming Cafe

Category Theory, Haskell, Concurrency, C++

November 24, 2014

## Types and Functions

Posted by Bartosz Milewski under

이 책의 일부인 ‘프로그래머를 위한 범주론’입니다. 이전 장은 ‘범주: 구성의 본질’이었습니다. 목차를 참고해 주십시오.

타입과 함수 범주는 프로그래밍에서 중요한 역할을 하므로, 타입이 무엇이고 왜 필요한지 함께 살펴보겠습니다.

## Who Needs Types?

정신 실험을 통해 이러한 선택지를 설명드리겠습니다. 정적 타입과 동적 타입, 그리고 강타입과 약타입에 대한 논쟁이 있는 것 같습니다. 수백만 마리의 원숭이가 컴퓨터 키보드를 즐겁게 두드려 무작위 키를 누르면서 프로그램을 만들고, 컴파일하고 실행하는 것을 상상해 보십시오.

기계어의 경우, 원숭이들이 만들어낸 모든 바이트 조합이 받아들여지고 실행될 것입니다. 하지만 고수준 언어의 경우에는 컴파일러가 어휘적 및 문법적 오류를 감지할 수 있다는 점을 높이 평가합니다. 많은 원숭이들은 바나나를 먹지 못할 것이지만, 남은 프로그램들은 더 나은 성공 가능성을 가질 것입니다. 타입 검사는 무의미한 프로그램에 대한 또 다른 장벽을 제공합니다. 더욱이 동적 타입 언어에서는 타입 불일치가 런타임에 발견되지만, 강타입으로 정적 검사를 수행하는 언어에서는 컴파일 시간에 타입 불일치가 발견되어 실행될 기회를 갖기 전에 많은 잘못된 프로그램이 제거됩니다.

그러므로 질문은, 원숭이들을 행복하게 만들 것인지, 아니면 올바른 프로그램을 생산할 것인지에 달려 있습니다.

타입 원숭이 정신 실험의 일반적인 목표는 셰익스피어의 전체 작품을 생산하는 것입니다. 오타 검사기 및 문법 검사기를 포함시키면 성공 확률이 크게 증가할 것입니다. 타입 검사기의 등가물은 로미오가 인간으로 선언되면 잎이 자라거나 강력한 중력장 내에서 광자를 가두는 것을 방지하는 것과 같이 더욱 확실하게 보장합니다.

## Types Are About Composability

카테고리 이론은 화살표를 조합하는 것에 관한 것입니다. 하지만 어떤 두 화살표를 조합할 수 있는 것은 아닙니다. 한 화살표의 대상 객체는 다음 화살표의 소스 객체와 동일해야 합니다. 프로그래밍에서 한 함수에서 다른 함수로 결과를 전달하는 방식과 유사합니다. 대상 함수가 소스 함수가 생성한 데이터를 올바르게 해석할 수 없으면 프로그램은 작동하지 않습니다. 조합이 작동하려면 두 끝이 서로 맞아야 합니다. 언어의 타입 시스템이 강력할수록 이러한 일치 여부를 더 잘 설명하고 기계적으로 검증할 수 있습니다.

강력한 정적 타입 검사에 대해 들을 수 있는 가장 심각한 논쟁은 이것이 일부 프로그램을 제거할 수 있다는 것입니다. 실제로 이것은 극히 드물게 발생하며, 어쨌든 모든 언어는 필요할 때마다 타입 시스템을 우회하는 데 사용할 수 있는 어떤 종류의 뒷문(backdoor)을 제공합니다. 하스켈(Haskell)조차도 unsafeCoerce를 제공합니다. 하지만 이러한 장치는 신중하게 사용해야 합니다. 프란츠 카프카(Franz Kafka)의 등장인물인 그레고르 삼사(Gregor Samsa)가 거대한 곤충으로 변신하면서 타입 시스템을 깨뜨렸고, 우리는 모두 어떻게 끝났는지 알고 있습니다.

또 다른 논쟁은 타입과 씨름이 프로그래머에게 지나치게 많은 부담을 준다는 것입니다. 반복문 선언을 몇 가지 작성해야 했던 경험을 바탕으로 이러한 감정에 공감할 수 있었습니다. 하지만 하스켈(Haskell)에서 컴파일러가 가장 많이 사용된 컨텍스트에서 타입 대부분을 유추하도록 허용하는 기술인 타입 추론(type inference)을 사용해야 했습니다. 하스켈(Haskell)에서는 이제 'auto' 키워드를 사용하여 변수를 선언하고 컴파일러가 해당 타입을 추론하도록 할 수 있습니다.

하스켈(Haskell)에서는 드물게 예외적인 경우를 제외하고는 타입 주석(type annotation)이 순전히 선택 사항입니다. 프로그래머는 이러한 주석을 사용하는 경향이 있으며, 이는 코드의 의미에 대해 많은 것을 알려주며, 컴파일 오류를 이해하기 쉽게 만들어줍니다. 하스켈(Haskell)에서는 프로젝트를 시작할 때 타입 설계부터 시작하는 것이 일반적인 관행입니다. 이후 타입 주석은 구현을 주도하고 컴파일러가 적용하는 주석으로 변합니다.

강력한 정적 타입은 코드 테스트를 하지 않으려는 변명으로 자주 사용됩니다. 하스켈(Haskell) 프로그래머가 "만약 컴파일되면, 그것은 옳을 것이다"라고 말하는 것을 들을 수 있습니다. 물론 타입이 올바른 프로그램을 생성한다는 보장은 없다는 것입니다. 이러한 경솔한 태도의 결과는 여러 연구에서 하스켈(Haskell)이 코드 품질 측면에서 다른 언어보다 뒤쳐지는 것으로 나타났습니다. 이는 소프트웨어 개발 경제학과 최종 사용자 허용 범위와 관련이 있으며, 프로그래밍 언어 또는 방법론과는 거의 관련이 없습니다. 더 나은 기준은 프로젝트가 일정을 지키지 못하거나 현저하게 감소된 기능으로 제공되는 경우를 측정하는 것입니다.

단위 테스트(unit testing)가 강력한 정적 타입을 대체할 수 있다는 논쟁에 대해 고려할 만한 점은 강력한 정적 타입 언어에서 함수 인수의 타입을 변경하는 일반적인 리팩토링(refactoring) 관행입니다. 강력한 정적 타입 언어에서는 해당 함수의 선언을 수정하고 빌드 오류를 수정하는 것만으로 충분합니다. 약한 타입 언어에서는 함수가 이제 다른 데이터를 예상한다는 사실이 호출 위치에 전파되지 않습니다. 단위 테스트는 일부 불일치를 포착할 수 있지만 테스트는 거의 항상 확률적이며 결정적인 프로세스가 아닙니다. 테스트는 증명(proof)의 대체재가 아닙니다.

## What Are Types?

가장 간단하게 이해할 수 있는 타입의 개념은, 타입이 값들의 집합이라는 것입니다. Haskell에서 구체적인 타입은 대문자로 시작한다는 점을 기억해 주십시오. Bool 타입은 참(True)과 거짓(False)으로 이루어진 두 개의 원소를 가진 집합입니다. Char 타입은 'a' 또는 'ą'와 같은 모든 유니코드 문자를 포함하는 집합입니다.

집합은 유한하거나 무한할 수 있습니다. String 타입은 Char의 목록과 동의어로 사용되며, 이는 무한한 집합의 예시입니다.

When we declare x to be an Integer:

```
x :: Integer
```

저희는 이것이 정수 집합의 일부임을 말씀드리고 싶습니다. Haskell의 정수는 무한 집합이며, 이를 통해 임의의 정밀도를 갖는 산술 연산을 수행할 수 있습니다. 또한 C++의 int와 같이 기계 유형에 해당하는 유한 집합 Int도 존재합니다.

이러한 유형과 집합의 동일성은 몇 가지 미묘한 부분 때문에 까다로울 수 있습니다. 순환 정의를 포함하는 다형 함수와 모든 집합의 집합을 가질 수 없다는 사실 때문에 문제가 발생할 수 있습니다. 하지만 제가 약속드렸듯이, 저희는 수학적인 엄밀함에 얽매이지 않을 것입니다. 다행히도 집합의 범주가 존재하며, 이를 ‘Set’이라고 부르는데, 저희는 이 범주를 활용할 것입니다. Set에서 객체는 집합이고, 모사(arrows)는 함수입니다.

Set는 매우 특별한 범주입니다. 왜냐하면 저희는 이 범주의 객체 내부를 들여다볼 수 있고, 이를 통해 많은 직관을 얻을 수 있기 때문입니다. 예를 들어, 빈 집합은 요소가 없다는 것을 알고 있습니다. 또한 특별한 원소 하나를 갖는 집합도 존재합니다. 함수는 한 집합의 요소를 다른 집합의 요소로 매핑할 수 있습니다. 두 요소를 하나로 매핑할 수도 있지만, 한 요소를 두 요소로 매핑할 수는 없습니다. 또한 항등 함수는 각 집합의 요소를 자기 자신으로 매핑하며, 이에 따라가는 개념들도 있습니다. 저희의 계획은 이러한 모든 정보를 점진적으로 잊고, 객체와 모사라는 순수한 범주적 용어로 모든 개념을 표현하는 것입니다.

이상적인 세상에서는 Haskell 유형이 집합이고, Haskell 함수가 집합 사이의 수학적 함수라는 것을 단순히 말할 수 있습니다. 단 하나의 작은 문제가 있습니다. 수학적 함수는 코드를 실행하지 않고, 단지 답을 알고 있습니다. Haskell 함수는 답을 계산해야 합니다. 답이 유한한 단계 수로 얻을 수 있다면 문제가 되지 않습니다 – 그 수가 아무리 크더라도 말입니다. 하지만 재귀를 포함하는 계산이 있으며, 이러한 계산은 절대로 종료되지 않을 수 있습니다. Haskell에서 비종결 함수를 금지할 수 없는 이유는 종료 가능하고 비종결 함수를 구별하는 것이 불가능하기 때문입니다 – 유명한 멈춤 문제(halting problem)입니다. 그래서 컴퓨터 과학자들은 관점(perspective)에 따라 획기적인 아이디어나 주요한 해킹을 제시하여 모든 유형에 하나 더 특별한 값을 추가했습니다. 이 값은 ‘bottom’이라고 불리며, \_|\_ 또는 Unicode ⊥로 표시됩니다. 이 “값”은 비종결 계산에 해당합니다. 따라서 다음과 같이 선언된 함수는:

```
f :: Bool -> Bool
```

다음 중 True, False, 또는 \_|\_; 후자의 경우 절대로 종료되지 않는다는 의미입니다.

흥미로운 점은, 바텀(bottom)을 타입 시스템의 일부로 받아들인다면, 모든 런타임 오류를 바텀으로 취급하고, 심지어 함수가 바텀을 명시적으로 반환하도록 허용하는 것이 편리하다는 것입니다. 일반적으로 이는 `undefined` 표현식을 사용하여 수행되며, 예를 들어 다음과 같습니다.

```
f :: Bool -> Bool
f x = undefined
```

이 정의 유형 검사를 통과합니다. 왜냐하면 undefined는 bottom으로 평가되기 때문이며, bottom은 어떤 유형의 멤버이기도 합니다. 심지어 다음과 같이 작성할 수 있습니다:

```
f :: Bool -> Bool
f = undefined
```

(x가 없는 경우) 이유는 바텀도 Bool->Bool 타입의 멤버이기 때문입니다.

아래와 같이, 결과를 반환할 수 있는 바텀(bottom)을 포함하는 함수들을 부분 함수(partial function)라고 부릅니다. 반면, 모든 가능한 인수에 대해 유효한 결과를 반환하는 완전 함수(total function)는 유효한 결과를 반환합니다.

바텀 때문에, Haskell 타입과 함수들의 범주를 Hask라고 부르는 것을 보게 됩니다. 이론적인 관점에서 보면, 이것은 끊임없는 복잡성의 근원입니다. 따라서 이 시점에서 저는 도끼로 썰어 버리고, 이 논의를 여기서 마무리하겠습니다. 실용적인 관점에서는, 종료되지 않는 함수나 바텀을 무시하고 Hask를 진정한 의미의 Set처럼 취급해도 괜찮습니다 (참고 문헌 참조).

## Why Do We Need a Mathematical Model?

프로그래머로서 여러분은 해당 프로그래밍 언어의 문법 및 구문 규칙에 대해 깊이 이해하고 계실 것입니다. 언어의 이러한 측면들은 언어 사양의 초반에 주로 공식적인 표기법을 사용하여 설명되곤 합니다. 하지만 언어의 의미, 즉 의미론(semantics)은 훨씬 더 설명하기 어렵습니다. 훨씬 더 많은 페이지를 차지하며, 거의 공식적이지도 않고, 거의 완전하지도 않습니다. 그래서 언어 변호사들 간의 끊임없는 논쟁과 언어 표준의 미묘한 점들을 해석하는 데 전념한 서적 전체의 산업이 형성되었습니다.

언어의 의미론을 설명하는 데 공식적인 도구가 있지만, 복잡성 때문에 주로 단순화된 학문적 언어에 사용되며, 실제 프로그래밍 거대 프로젝트에는 거의 사용되지 않습니다. 그러한 도구 중 하나인 운영적 의미론(operational semantics)은 프로그램 실행의 메커니즘을 설명합니다. 이는 공식화된 이상적인 인터프리터를 정의합니다. C++와 같은 산업 언어의 의미론은 종종 “추상 기계(abstract machine)”라는 용어로 설명되는 비공식적인 운영적 추론을 사용하여 설명됩니다.

문제는 운영적 의미론을 사용하여 프로그램에 대한 것을 증명하기가 매우 어렵다는 것입니다. 프로그램의 속성을 보여주려면 기본적으로 “실행”시켜야 합니다.

프로그래머들이 정확성 증명을 위해 공식적인 증거를 수행하지 않는다는 사실은 중요하지 않습니다. 우리는 항상 우리가 작성한 프로그램이 올바른지 “생각”합니다. 아무도 키보드에 앉아 “몇 줄의 코드를 던져보고 무슨 일이 일어나는지 보자”라고 말하지 않습니다. 우리는 우리가 작성하는 코드가 특정 동작을 수행하고 원하는 결과를 생성할 것이라고 생각합니다. 우리는 그것이 작동하지 않을 때 놀라움을 느끼는 경우가 많습니다. 따라서 우리는 우리가 작성하는 프로그램에 대해 추론하고, 일반적으로 인터프리터를 머릿속에서 실행하여 그렇게 합니다. 모든 변수를 추적하는 것은 정말 어렵습니다. 컴퓨터는 프로그램을 실행하는 데 능숙하지만, 인간은 그렇지 않습니다. 만약 우리가 그랬다면, 우리는 컴퓨터가 필요 없을 것입니다.

하지만 대안이 있습니다. 이를 “정의론적 의미론(denotational semantics)”이라고 하며, 수학에 기반합니다. 정의론적 의미론에서 모든 프로그래밍 구성 요소는 수학적 해석을 받습니다. 이를 통해 프로그램의 속성을 증명하려면 단순히 수학적 정리를 증명하면 됩니다. 정리를 증명하는 것이 어렵다고 생각할 수 있지만, 사실 인간은 수천 년 동안 수학적 방법을 구축해 왔기 때문에 활용할 수 있는 방대한 지식이 있습니다. 또한 프로페셔널한 수학자들의 증명하는 종류의 정리를 비교하면, 프로그래밍에서 우리가 마주하는 문제는 일반적으로 매우 간단하거나 심지어 터무니없습니다.

팩토리얼 함수는 하스케일(Haskell)이라는 언어에서 상당히 쉽게 정의할 수 있습니다. 이 언어는 명세론적 의미론(denotational semantics)을 적용하기에 매우 적합합니다.

```
fact n = product [1..n]
```

숫자 1부터 n까지의 정수 목록인 [1..n]을 의미합니다. 함수 product는 목록의 모든 요소를 곱합니다. 이는 수학 교과서에서 가져온 팩토리얼의 정의와 같습니다. C 언어와 비교해 보시면요:

```
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
```

Need I say more?

먼저 말씀드리지만, 이건 정말 엉터리 꼼수였던 점을 인정해야 합니다! 팩토리얼 함수는 명확한 수학적 의미를 가지고 있습니다. 통찰력 있는 독자라면 다음과 같은 질문을 할 수 있을 것입니다: 키보드에서 문자를 읽거나 네트워크를 통해 패킷을 전송하는 것과 같은 작업에 대한 수학적 모델은 무엇입니까? 오랫동안 이 질문은 상당히 복잡한 설명으로 이어지는 어색한 질문이었을 것입니다. 데노타ショナル 의미론이 유용한 프로그램을 작성하는 데 필수적인 많은 중요한 작업에 가장 적합한 것은 아니었고, 운영적 의미론으로 쉽게 해결할 수 있었던 점입니다. 이러한 전환은 카테고리 이론에서 비롯되었습니다. 에우제니오 모기 박사는 계산 효과를 모나드에 매핑할 수 있음을 발견했습니다. 이는 데노타ショナル 의미론에 새로운 활력을 불어넣고 순수 함수형 프로그램을 더욱 사용 가능하게 만들었을 뿐만 아니라 전통적인 프로그래밍에 새로운 빛을 드리게 된 중요한 관찰이었습니다. 나중에 모나드에 대해 더 자세히 이야기하겠습니다.

프로그래밍에 대한 수학적 모델을 갖는 것의 중요한 장점 중 하나는 소프트웨어의 정확성을 공식적으로 증명할 수 있다는 것입니다. 이는 소비용 소프트웨어를 작성할 때 그렇게 중요하게 느껴지지 않을 수 있지만, 오류로 인한 비용이 엄청나거나 인명에 관련된 특정 프로그래밍 영역에서는 매우 중요합니다. 예를 들어, 건강 시스템을 위한 웹 애플리케이션을 작성할 때도, 하스켈 표준 라이브러리에서 제공하는 함수와 알고리즘이 정확성 증명과 함께 제공된다는 점을 고려해 보시면 좋을 것입니다.

## Pure and Dirty Functions

C++나 다른 명령형 언어에서 “함수”라고 부르는 것들과 수학자들이 “함수”라고 부르는 것들은 완전히 다른 개념입니다. 수학적 함수는 단순히 값들을 값으로 매핑하는 것일 뿐입니다.

프로그래밍 언어에서 수학적 함수를 구현할 수 있습니다. 예를 들어, 입력 값을 받아서 출력 값을 계산하는 함수는 다음과 같습니다. 숫자의 제곱을 계산하는 함수는 아마도 입력 값을 자기 자신으로 곱할 것입니다. 그리고 호출될 때마다 항상 동일한 출력을 생성하도록 보장됩니다. 숫자의 제곱은 달의 위상 변화에 따라 변하지 않습니다.

또한, 숫자의 제곱을 계산하는 것은 강제적으로 강아지에게 맛있는 간식을 제공하는 부작용을 일으켜서는 안 됩니다. 이러한 “함수”는 수학적 함수로 쉽게 모델링하기 어렵습니다.

프로그래밍 언어에서 동일한 입력에 대해 항상 동일한 결과를 생성하고 부작용이 없는 함수는 순수 함수라고 합니다. 순수 함수형 언어인 Haskell에서는 모든 함수가 순수합니다. 따라서 이러한 언어는 동형적 의미론을 제공하고 범주론을 사용하여 모델링하기가 더 쉽습니다. 다른 언어의 경우, 순수 부분집합으로 제한하거나 부작용을 별도로 고려하는 것이 항상 가능합니다. 나중에 우리는 순수 함수만을 사용하여 모든 종류의 효과를 모델링하는 데 도움이 되는 모나드(monads)가 어떻게 작동하는지 살펴보겠습니다. 따라서 우리는 수학적 함수에 제한하는 것만으로 아무것도 잃지 않습니다.

## Examples of Types

자, 유형을 집합으로 이해하게 되면, 상당히 독특한 유형들을 생각해 볼 수 있습니다. 예를 들어, 빈 집합에 해당하는 유형은 무엇일까요? 네, C++의 void와 비슷하지만, 하스케일에서는 이를 Void라고 부릅니다. 어떤 값도 포함하고 있지 않은 유형입니다. Void를 받는 함수를 정의할 수 있지만, 절대 호출할 수 없습니다. 호출하려면 Void 유형의 값을 제공해야 하는데, 그런 값은 존재하지 않습니다. 이 함수가 반환할 수 있는 값에 대해서는 어떤 제한도 없습니다. 어떤 유형이든 반환할 수 있습니다 (물론 절대 반환하지는 않지만, 호출할 수 없기 때문입니다). 다시 말해, 반환 유형에 대해 다형성을 갖는 함수라고 할 수 있습니다. 하스켈에서는 이를 Void라고 부릅니다.

```
absurd :: Void -> a
```

이 이름은 단순한 우연이 아닙니다. 타입과 함수에 대한 논리적 해석, 즉 커리-허드 이소머시즘이 존재합니다. Void 타입은 거짓을 나타내며, absurd 타입의 함수는 거짓에서 모든 것이 따른다는 의미를 나타냅니다. 이는 라틴 속담 ‘ex falso sequitur quodlibet’와 같습니다.

다음으로 단일 원소 집합에 해당하는 타입을 살펴보겠습니다. 이 타입은 단 하나의 값만을 가질 수 있습니다. 이 값은 단순히 ‘존재’합니다. 처음에는 그렇게 인식하지 못할 수도 있지만, 이것이 바로 C++의 void입니다. 이 타입으로 들어오고 나가는 함수들을 생각해 보십시오. void에서 호출 가능한 함수는 항상 호출될 수 있습니다. 순수 함수라면 항상 동일한 결과를 반환합니다. 다음은 이러한 함수의 예입니다.

```
int f44() { return 44; }
```

이 함수를 처음 접하면 “아무것도 받지 않는다”라고 생각할 수 있습니다. 하지만 저희가 방금 살펴보았듯이, 아무것도 받지 않는 함수는 “아무것도”라는 값이 존재하지 않으므로 호출될 수 없습니다. 그렇다면 이 함수는 무엇을 받게 될까요? 개념적으로는 단 한 번만 존재하는 가짜 값을 받게 되므로, 명시적으로 언급할 필요가 없습니다. 하지만 하스케일에서는 이 값에 대한 기호를 제공합니다. 바로 괄호 쌍 없이 빈 괄호, ()입니다. 따라서 우연히, 혹은 우연히, C++와 하스케일 모두 void 타입의 함수 호출이 동일한 형태를 갖는다는 점은 흥미로운 일입니다. 또한 하스케일의 간결함을 추구하는 특징 때문에, 동일한 기호 ()는 타입, 생성자, 그리고 단일 원소 집합에 해당하는 유일한 값 모두에 사용됩니다. 다음은 하스케일에서 이 함수를 사용하는 예시입니다.

```
f44 :: () -> Integer
f44 () = 44
```

첫 번째 줄은 f44가 ()라는 유형(단위)을 Integer 유형으로 취급한다는 것을 선언합니다. 두 번째 줄은 단일 단위 생성자 ()를 패턴 매칭하여 44라는 숫자를 생성함으로써 f44를 정의합니다. 이 함수는 다음과 같이 호출합니다: ()를 단위 값으로 제공합니다.

```
f44 ()
```

저희는 여기서 중요한 점을 말씀드리고 싶습니다. 모든 유닛(unit)의 함수는 목표 타입(여기서는 Integer 44)에서 단 하나의 요소를 선택하는 것과 같습니다. 실제로 f44는 숫자 44를 나타내는 다른 방식이라고 생각할 수 있습니다. 이는 요소의 명시적인 언급 대신 함수(화살표)를 통해 설명하는 방식의 예시입니다. 유닛에서 어떤 타입 A로의 함수는 그 집합 A의 요소들과 일대일 대응 관계를 갖습니다.

유닛 반환 타입, 즉 Haskell에서는 유닛 반환 타입과 같이 함수에 대해 말씀드리자면, C++에서는 이러한 함수는 부작용을 위해 사용되지만, 이러한 것은 수학적인 의미에서 실제 함수가 아니라는 것을 알고 있습니다. 유닛을 반환하는 순수 함수는 아무것도 하지 않습니다. 즉, 인자를 버립니다.

수학적으로, 집합 A에서 단일 요소 집합으로의 함수는 A의 모든 요소를 그 단일 요소 집합의 단일 요소로 매핑합니다. 집합 A에 대해 정확히 하나의 그러한 함수가 존재합니다. 여기서는 Integer에 대한 함수입니다.

```
fInt :: Integer -> ()
fInt x = ()
```

어떤 정수를 입력하시면, 그 정수와 동일한 값을 반환해 드립니다. 간결함을 추구하는 정신으로 하스케일은 와일드카드 패턴이나 밑줄(_)을 인자를 무시할 때 사용하도록 허용합니다. 이렇게 하면 별도의 이름을 지을 필요가 없습니다. 따라서 위와 같은 내용은 다음과 같이 다시 작성할 수 있습니다:

```
fInt :: Integer -> ()
fInt _ = ()
```

이 함수를 구현할 때, 전달된 값의 값 자체에 의존하는 것뿐만 아니라, 인자의 타입에 의존하지 않는다는 점에 주목해 주십시오.

같은 공식을 사용하여 어떤 타입에도 적용 가능한 함수들을 파라메트릭으로 다형적이라고 부릅니다. 타입 매개변수를 사용하여 하나의 방정식으로 여러 함수를 구현할 수 있습니다. 어떤 타입에서 unit 타입으로의 다형적 함수를 부를까요? 물론 “unit”이라고 부를 것입니다.

```
unit :: a -> ()
unit _ = ()
```

In C++ you would write this function as:

```
template<class T>
void unit(T) {}
```

다음 유형 분류에서 다음으로 다루는 것은 두 요소로 구성된 집합입니다. C++에서는 bool, Haskell에서는 예측할 수 있듯이 Bool이라고 합니다. C++의 bool은 기본 자료형이지만, Haskell에서는 다음과 같이 정의할 수 있습니다.

```
data Bool = True | False
```

이 정의를 읽는 방법은 Bool은 참(True) 또는 거짓(False) 둘 중 하나의 값만을 가질 수 있다는 것입니다. 원칙적으로 C++에서 부울(Boolean) 타입을 열거형(enumeration)으로 정의할 수도 있습니다.

```
enum bool {
    true,
    false
};
```

C++의 `enum`은 사실상 정수입니다. C++11의 “`enum class`”를 사용했을 수도 있었지만, 그렇다면 True와 False에 해당하는 값을 클래스 이름으로 덧붙여 지정해야 했으며, 이를 사용하는 모든 파일에 해당 헤더를 포함해야 했습니다.

Bool에서 제공하는 순수 함수는 대상 타입에서 True와 False에 해당하는 두 값을 선택합니다.

Bool에 대한 함수들은 일반적으로 “predicate”라고 불립니다. 예를 들어, Haskell 라이브러리 Data.Char는 isAlpha 또는 isDigit와 같은 predicate로 가득 차 있습니다. C++에는 isalpha와 isdigit를 정의하는 유사한 라이브러리가 존재하지만, 이러한 함수들은 Boolean 대신 정수를 반환합니다. 실제 predicate는 std::ctype에 정의되며, ctype::is(alpha, c), ctype::is(digit, c)와 같은 형태로 제공됩니다.

## Challenges

- Define a higher-order function (or a function object) memoize in your favorite language. This function takes a pure function f as an argument and returns a function that behaves almost exactly like f, except that it only calls the original function once for every argument, stores the result internally, and subsequently returns this stored result every time it’s called with the same argument. You can tell the memoized function from the original by watching its performance. For instance, try to memoize a function that takes a long time to evaluate. You’ll have to wait for the result the first time you call it, but on subsequent calls, with the same argument, you should get the result immediately.
- Try to memoize a function from your standard library that you normally use to produce random numbers. Does it work?
- Most random number generators can be initialized with a seed. Implement a function that takes a seed, calls the random number generator with that seed, and returns the result. Memoize that function. Does it work?
- Which of these C++ functions are pure? Try to memoize them and observe what happens when you call them multiple times: memoized and not.
    - The factorial function from the example in the text.
    - std::getchar()
    - bool f() { 
    std::cout << "Hello!" << std::endl;
    return true; 
}
    - int f(int x)
{
    static int y = 0;
    y += x;
    return y;
}
- How many different functions are there from Bool to Bool? Can you implement them all?
- Draw a picture of a category whose only objects are the types Void, () (unit), and Bool; with arrows corresponding to all possible functions between these types. Label the arrows with the names of the functions.

## Bibliography

- Nils Anders Danielsson, John Hughes, Patrik Jansson, Jeremy Gibbons, Fast and Loose Reasoning is Morally Correct. This paper provides justification for ignoring bottoms in most contexts.

Next: Categories Great and Small

Follow @BartoszMilewski

