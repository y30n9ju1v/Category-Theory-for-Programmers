# Bartosz Milewski's Programming Cafe

Category Theory, Haskell, Concurrency, C++

November 4, 2014

## Category: The Essence of Composition

Posted by Bartosz Milewski under

저의 이전 글, 프로그래밍자를 위한 범주론 서문이 긍정적인 반응을 얻어 놀라웠습니다. 동시에, 많은 분들이 저에게 기대하는 바가 얼마나 큰지 깨닫게 되어 매우 당황스러웠습니다. 제가 어떤 글을 쓰든 많은 독자분들이 실망하실까 하는 걱정이 듭니다. 어떤 분들은 책이 좀 더 실용적인 내용을 담기를 원하시고, 또 다른 분들은 좀 더 추상적인 내용을 원하십니다. C++를 싫어하시는 분들은 모든 예시를 하스케일로, 하스케일을 싫어하시는 분들은 자바로 요청하십니다. 또한, 설명 속도가 어떤 분들에게는 너무 느리고, 다른 분들에게는 너무 빠를 것이라는 점을 잘 알고 있습니다. 이 책은 완벽한 책이 될 수 없을 것입니다. 다만, 제가 겪은 ‘아하!’ 순간들을 독자분들과 공유할 수 있기를 바라며, 기초부터 시작해 보겠습니다.

카테고리는 매우 단순한 개념입니다. 카테고리는 서로 연결되는 객체와 화살표로 구성됩니다. 그래서 카테고리는 그림으로 표현하기가 매우 쉽습니다. 객체는 원이나 점으로 그리고, 화살표는 화살표로 표현합니다. (다양한 표현을 위해 가끔 객체는 돼지 그림으로, 화살표는 폭죽 그림으로 그릴 수도 있습니다.) 하지만 카테고리의 본질은 구성입니다. 또는, 구성의 본질은 카테고리라고 말씀드릴 수 있습니다. 화살표는 결합되므로, 객체 A에서 객체 B로 향하는 화살표와 객체 B에서 객체 C로 향하는 화살표가 있다면, 그들의 결합을 나타내는 화살표, 즉 객체 A에서 객체 C로 향하는 화살표가 반드시 존재합니다.

<!-- image -->

저희 제품 카테고리에서, A에서 B로 향하는 화살표와 B에서 C로 향하는 화살표가 존재한다면, 반드시 A에서 C로 직접 연결되는 화살표, 즉 그들의 합성을 포함해야 합니다. 이 다이어그램은 완전한 카테고리가 아니라는 점도 참고해주시기 바랍니다. (자세한 내용은 뒤에서 설명드리겠습니다.)

## Arrows as Functions

걱정 마세요. 좀 더 명확하게 설명드리겠습니다. 화살표, 즉 모리즘을 함수로 생각해보시면 이해가 쉬울 겁니다. 함수 f는 A 타입의 인자를 받아 B를 반환하고, 함수 g는 B를 받아 C를 반환합니다. 이 두 함수를 합치려면 f의 결과를 g에 전달하는 방식으로 조합할 수 있습니다. 이제 A를 받아 C를 반환하는 새로운 함수를 정의하게 되었습니다.

수학에서는 이러한 합성(composition)은 함수 사이에 작은 원으로 표시됩니다. 즉, g∘f 와 같이 표현하는 것입니다. 합성의 경우, 왼쪽에서 오른쪽 순서로 진행하는 것을 주의해 주십시오. 이 순서가 혼란스러울 수 있습니다. Unix에서 사용되는 파이프(pipe) 표기법에 익숙하신 분들도 계실 텐데요.

```
lsof | grep Chrome
```

체크 표시 모양 >> F#에서 모두 왼쪽에서 오른쪽으로 진행됩니다. 하지만 수학이나 Haskell 함수에서는 오른쪽에서 왼쪽으로 결합됩니다. ‘g ∘ f’를 ‘f 다음에 g’라고 읽는 것이 도움이 됩니다.

이 내용을 더욱 명확하게 설명하기 위해 C 코드를 작성해 보겠습니다. 함수 f는 A 타입의 인자를 받아 B 타입의 값을 반환합니다.

```
B f(A a);
```

and another:

```
C g(B b);
```

Their composition is:

```
C g_after_f(A a)
{
    return g(f(a));
}
```

여기 다시 한번, 오른쪽에서 왼쪽으로 구성된 것을 보실 수 있습니다: g(f(a)); 이번에는 C 언어로 표현되어 있습니다.

죄송하지만, C++ 표준 라이브러리에 두 함수를 받아 그 결과를 합쳐주는 템플릿이 있다는 말씀을 드릴 수 없게 됩니다. 그래서 잠시 해스켈을 사용해 보는 것은 어떨까요? A에서 B로의 함수 선언은 다음과 같습니다.

```
f :: A -> B
```

Similarly:

```
g :: B -> C
```

Their composition is:

```
g . f
```

한 번 하스켈에서 간단한 것들이 얼마나 멋지게 표현되는지 보시면, C++에서 간단한 함수형 개념을 표현하는 데 어려움을 느끼는 것은 조금 당황스럽게 느껴질 겁니다. 실제로 하스켈은 유니코드 문자를 사용해서 복잡한 연산을 다음과 같이 작성할 수 있도록 해줍니다.

```
g ∘ f
```

유니코드 이중 콜론과 화살표를 사용하실 수도 있습니다.

```
f ∷ A → B
```

자, 하스케일 첫 번째 레슨을 시작해 보겠습니다. 콜론 두 개(::)는 “~의 타입을 가짐”을 의미합니다. 함수 타입은 두 개의 타입을 사이에 화살표를 삽입하여 생성됩니다. 함수들을 조합하는 것은 점(.) 또는 유니코드 원표시를 사이에 삽입하는 방식으로 진행됩니다.

## Properties of Composition

어떤 분야든 구성 요소가 만족해야 할 아주 중요한 두 가지 특징이 있습니다.

1. 세 가지 모듈(morphism)인 f, g, h가 서로 연결하여 합성될 수 있다면, 괄호를 사용할 필요가 없습니다. 수학 표기법으로는 다음과 같이 표현됩니다:

```
h∘(g∘f) = (h∘g)∘f = h∘g∘f
```

In (pseudo) Haskell:

```
f :: A -> B
g :: B -> C
h :: C -> D
h . (g . f) == (h . g) . f == h . g . f
```

(I said “pseudo,” because equality is not defined for functions.)

함수와 같은 경우 연쇄 법칙은 꽤 명확하지만, 다른 범주에서는 그렇게 뚜렷하게 드러나지 않을 수 있습니다.

2. 각 물체 A에 대해, A를 구성하는 단위인 화살표가 하나 존재합니다. 이 화살표는 A에서 시작하여 A에서 끝나는 형태로 똬르며, 구성 단위라는 것은 A에서 시작하거나 A에서 끝나는 어떤 화살표와 함께 구성될 때, 항상 원래의 화살표를 되돌려 준다는 의미입니다. 물체 A에 대한 구성 단위 화살표는 idA(A 위에서의 항등 함수)라고 불립니다. 수학 표기법에서 f가 A에서 B로 향한다면

```
f∘idA = f
```

and

```
idB∘f = f
```

함수들을 다룰 때, 정체성 화살표는 단순히 인자를 반환하는 정체성 함수로 구현됩니다. 이 구현 방식은 모든 타입에서 동일하게 적용되므로, 이 함수는 보편적으로 다형성을 갖습니다. C++에서는 템플릿으로 정의할 수 있습니다.

```
template<class T> T id(T x) { return x; }
```

물론 C++에서는 그렇게 간단하게 진행되지 않습니다. 전달되는 것 외에도 (즉, 값으로, 참조로, 상수 참조로, 이동으로 등) 고려해야 할 사항들이 많기 때문입니다.

하스케일에서는 정체 함수는 표준 라이브러리(Prelude라고 불림)의 일부입니다. 다음은 그 선언과 정의입니다.

```
id :: a -> a
id x = x
```

보시다시피, 하스케일의 다형 함수는 매우 간단합니다. 선언만 수정하시면 되는데, 타입 부분을 단순히 타입 변수로 대체하는 것뿐입니다. 핵심은 구체적인 타입 이름은 항상 대문자로 시작하고, 타입 변수 이름은 소문자로 시작한다는 점입니다. 따라서 ‘a’는 모든 타입에 해당합니다.

하스켈 함수 정의는 함수 이름 다음에 형식적인 매개변수 – 여기서는 하나, x – 가 이어집니다. 함수의 본문은 등호 다음에 위치합니다. 이러한 간결함은 초보자들에게는 놀라울 수 있지만, 곧 완벽하게 이해할 수 있을 것입니다. 함수 정의와 함수 호출은 함수형 프로그래밍의 핵심이므로, 그 문법은 최소한의 요소로 줄어듭니다. 인자 목록을 괄호로 묶는 것 외에 인자들 사이에 쉼표도 없습니다 (나중에 다중 인수를 갖는 함수를 정의할 때 확인하실 수 있습니다).

함수 본체는 항상 표현식입니다. 함수 안에는 문장이 포함되지 않습니다. 함수의 결과는 바로 이 표현식, 즉 x입니다.

이것으로 제2강의를 마치겠습니다.

정체성 조건은 (다시 한번, 파스칼 스타일로) 다음과 같이 표현할 수 있습니다.

```
f . id == f
id . f == f
```

혹시 이런 생각을 해 보셨을 수도 있습니다. “왜 아무런 가치를 두지 않고 단순히 아무것도 하지 않는 ‘정체성 함수’에 굳이 신경 쓰겠느냐?” 물론, ‘0’ 역시 ‘아무것도 아니다’라는 상징일 뿐입니다. 고대 로마인들은 ‘0’을 사용하지 않은 숫자 체계를 가지고 있었는데, 그 덕분에 오늘날까지도 일부가 남아있는 훌륭한 도로와 수로를 건설할 수 있었습니다.

0과 같은 중립값은 상징적인 변수를 다룰 때 매우 유용합니다. 그래서 로마인들은 대수학에 능하지 못했던 반면, ‘0’의 개념을 이해했던 아랍인들과 페르시아인들은 대수학에 능숙했습니다. 정체성 함수는 더 높은 수준의 함수에 전달하거나 반환할 때 매우 유용하게 사용됩니다. 이러한 더 높은 수준의 함수는 상징적인 함수 조작을 가능하게 하는 것입니다. 즉, 함수에 대한 대수학이라고 할 수 있습니다.

요약하면: 범주는 객체와 화살표(모리즘)로 구성됩니다. 화살표는 결합될 수 있으며, 결합은 결합 법칙을 따릅니다. 모든 객체는 결합 하위 단위로서의 정체성 화살표를 가지고 있습니다.

## Composition is the Essence of Programming

함수형 프로그래밍을 하는 분들은 문제 해결 방식이 조금 독특합니다. 그분들은 매우 초의적인 질문부터 시작하시죠. 예를 들어, 인터랙티브 프로그램을 설계할 때에는 “인터랙션이란 무엇인가?”라고 질문하실 겁니다. 또한, 컨웨이의 생명 게임을 구현할 때에는 “삶의 의미는 무엇인가?”라는 질문을 던지실 수도 있습니다. 이러한 정신으로, 저부터 질문해 보겠습니다. “프로그래밍이란 무엇인가?” 기본적으로 프로그래밍은 컴퓨터에게 무엇을 해야 하는지를 알려주는 것입니다. “메모리 주소 X의 내용을 레지스터 EAX에 더한다”와 같은 명령을 내리는 것이죠. 심지어 어셈블리어로 프로그래밍을 하더라도, 우리가 컴퓨터에게 주는 명령어는 더욱 의미 있는 무언가의 표현입니다. 우리는 실질적으로 복잡한 문제를 해결하고 있으며 (만약 문제가 간단하다면 컴퓨터의 도움 없이 해결할 수 있겠지요), 문제를 해결하기 위해 더 큰 문제를 더 작은 문제로 나누는 방식으로 접근합니다. 작은 문제가 여전히 너무 크다면, 우리는 그것을 더욱 세분화하고, 이와 같은 방식으로 계속 진행합니다. 마지막으로, 모든 작은 문제를 해결하는 코드를 작성하게 됩니다. 그리고 프로그래밍의 핵심은 바로, 이러한 코드 조각들을 조립하여 더 큰 문제에 대한 해결책을 만드는 것입니다. 조립이 불가능하다면, 분해는 아무런 의미가 없겠지요.

이 과정은 컴퓨터가 우리에게 강요하는 것이 아니라, 인간의 정신적 한계를 반영합니다. 우리의 뇌는 한 번에 소수의 개념만 처리할 수 있습니다. 심리학 분야에서 가장 널리 인용되는 논문인 “The Magical Number Seven, Plus or Minus Two”는 우리가 7 ± 2 개의 “chunk” (정보 단위) 만 머릿속에 담을 수 있다고 주장합니다. 인간의 단기 기억에 대한 우리의 이해는 변화하고 있더라도, 한 가지 사실은 분명합니다. 바로 우리의 뇌가 복잡하고 다양한 정보들을 처리하는 데 한계가 있다는 것입니다. 복잡한 코드나 다양한 정보들을 처리하기 어려울 때, 우리는 구조화된 프로그램을 필요로 하는 것이죠. 아름답거나 우아하다고 표현하는 코드는, 단순히 우리의 제한된 인간의 정신이 쉽게 처리할 수 있기 때문입니다. 우아한 코드는 우리의 정신이 소화할 수 있는 적절한 크기와 수의 “chunk”를 만들어냅니다.

프로그램을 구성하는 데 적합한 부분(chunks)은 무엇일까요? 그 부분의 표면적은 부피보다 더 느리게 증가해야 합니다. (이 비유는 기하학적 도형의 표면적이 크기에 제곱으로 증가한다는 직관 때문에 마음에 드는 것입니다 — 부피는 크기에 세제곱으로 증가하기 때문입니다.) 표면적은 덩어리를 구성하는 데 필요한 정보이고, 부피는 그 덩어리를 구현하는 데 필요한 정보입니다. 즉, 덩어리가 구현되면 그 구현 세부 사항을 잊고 다른 덩어리와의 상호 작용에 집중한다는 것입니다. 객체 지향 프로그래밍에서는 표면은 객체의 클래스 선언 또는 추상 인터페이스입니다. 함수형 프로그래밍에서는 함수 선언입니다. (단순화된 표현이지만, 이 핵심 아이디어를 말씀드리는 것입니다.)

카테고리 이론은, 객체 내부를 들여다보는 것을 적극적으로 방해한다는 점에서 매우 독특합니다. 카테고리 이론에서 객체는 추상적이고 모호한 실체입니다. 객체에 대해 우리가 알 수 있는 것은 다른 객체와의 관계, 즉 화살표를 통해 연결되는 방식뿐입니다. 이는 검색 엔진이 링크 분석을 통해 웹사이트를 순위 매기는 방식과 유사합니다(물론 때로는 속임수를 사용하기도 합니다). 객체 지향 프로그래밍에서 이상적인 객체는 순수한 표면, 즉 부피가 없는 인터페이스를 통해서만 관찰할 수 있으며, 메서드는 화살표의 역할을 수행합니다. 다른 객체와 조합하는 방법을 이해하기 위해 객체의 구현을 파고들어야 하는 순간, 여러분은 프로그래밍 패러다임의 장점을 잃게 됩니다.

## Challenges

- Implement, as best as you can, the identity function in your favorite language (or the second favorite, if your favorite language happens to be Haskell).
- Implement the composition function in your favorite language. It takes two functions as arguments and returns a function that is their composition.
- Write a program that tries to test that your composition function respects identity.
- Is the world-wide web a category in any sense? Are links morphisms?
- Is Facebook a category, with people as objects and friendships as morphisms?
- When is a directed graph a category?

Next: Types and Functions.

Follow @BartoszMilewski

