# Bartosz Milewski's Programming Cafe

Category Theory, Haskell, Concurrency, C++

December 5, 2014

## Categories Great and Small

Posted by Bartosz Milewski under , , ,

이전 장에서 프로그래머를 위한 범주론(Category Theory)의 유형(types)과 함수(functions)에 대해 살펴보았습니다. 이 시리즈에 처음 오시는 분들을 위해 다음은 목차입니다.

범주의 개념을 제대로 이해하려면 다양한 예제를 살펴보는 것이 중요합니다. 범주는 여러 가지 형태와 크기를 가지고 있으며, 예상치 못한 곳에서도 자주 등장합니다. 이제 매우 간단한 예제부터 시작해 보겠습니다.

## No Objects

가장 단순한 카테고리는 객체가 0개이고, 따라서 모피즘도 0개인 카테고리입니다. 자체만으로는 매우 슬픈 카테고리이지만, 다른 카테고리의 맥락에서는 중요하게 작용할 수 있습니다. 예를 들어, 모든 카테고리를 포함하는 카테고리(네, 존재합니다)에서도 그렇습니다. 빈 집합이 의미가 있다고 생각하신다면, 빈 카테고리도 마찬가지로 의미가 있을 수 있습니다.

## Simple Graphs

객체를 화살표로 연결하는 것만으로 카테고리를 구성하실 수 있습니다. 어떤 방향 그래프부터 시작하든, 단순히 화살표를 더 추가하여 카테고리로 만드는 것이 가능합니다. 먼저 각 노드에 항등 화살표를 추가해 주십시오. 그 다음, 한 화살표의 끝이 다른 화살표의 시작과 일치하는 경우(즉, 어떤 두 화살표가 결합 가능한 경우) 새로운 화살표를 추가하여 그 결합을 나타내도록 합니다. 새로운 화살표를 추가할 때마다, 그 화살표를 다른 모든 화살표(항등 화살표는 제외)와 자신과 함께 결합하여 고려해야 합니다. 일반적으로 무한히 많은 화살표가 생성되지만, 괜찮습니다.

이 과정을 다른 관점에서 보면, 여러분은 노드에 대한 객체를 가지고 모든 가능한 그래프 간의 결합 가능한 경로를 모리즘(morphism)으로 사용하여 카테고리를 구축하는 것입니다. (항등 모리즘은 길이 0의 사슬의 특별한 경우로도 고려할 수 있습니다.)

이러한 카테고리는 주어진 그래프를 생성하는 자유 카테고리라고 합니다. 이는 주어진 구조를 최소한의 항목을 추가하여 법(카테고리의 법칙)을 만족하도록 확장하는 자유 구성의 예시입니다. 앞으로 더 많은 예시를 살펴보게 될 것입니다.

## Orders

자, 이제 완전히 다른 내용을 살펴보겠습니다! 여기서 ‘모리즘’은 객체 간의 관계를 의미하며, ‘크거나 같음’이라는 관계를 나타냅니다. 이것이 실제로 카테고리를 구성하는지 확인해 보겠습니다. 항등 모리즘이 존재하는지 확인해 보세요. 모든 객체는 자신과 같거나 같은지 확인하면 됩니다! 그리고 합성(composition)이 존재하는지 확인해 보세요. 만약 a <= b 이고 b <= c 이면, a <= c 가 성립하는지 확인하면 됩니다. 합성 연산이 결합법칙을 만족하는지 확인해 보세요. 이러한 관계를 갖는 집합을 ‘전순서(preorder)’라고 하며, 전순서는 실제로 카테고리를 구성합니다.

더욱 강력한 관계를 가질 수도 있습니다. 추가적인 조건을 만족하는 경우, 만약 a <= b 이고 b <= a 이면, a는 b와 같아야 합니다. 이것을 ‘부분 순서(partial order)’라고 합니다.

마지막으로, 모든 두 객체 사이에 관계가 존재하도록 할 수도 있습니다. 이렇게 하면 ‘선형 순서(linear order)’ 또는 ‘전체 순서(total order)’가 됩니다.

이러한 순서 관계를 갖는 집합을 카테고리로 특징짓도록 하겠습니다. 전순서는 어떤 객체 a에서 어떤 객체 b로 가는 모리즘이 최대 하나만 존재한다는 것을 의미합니다. 또한, 전순서는 ‘얇은(thin)’ 카테고리라고도 불립니다.

객체 a에서 객체 b로의 모리즘 집합을 ‘홈 집합(hom-set)’이라고 하며, C(a, b)로 표기합니다(때로는 HomC(a, b)로 표기하기도 합니다). 따라서 모든 홈 집합은 비어 있거나 단일 원소(singleton)로 구성됩니다. 여기에는 홈 집합 C(a, a), 즉 객체 a에서 객체 a로의 모리즘 집합이 포함되며, 이는 항상 단일 원소로 구성되어야 합니다. 이 단일 원소에는 항등 모리즘만 포함됩니다. 하지만 전순서에서는 사이클(cycle)이 존재할 수 있습니다. 사이클은 부분 순서에서는 허용되지 않습니다.

정렬(sorting)을 위해 전순서, 부분 순서, 전체 순서를 인식하는 것이 매우 중요합니다. 퀵 정렬, 버블 정렬, 병합 정렬 등의 정렬 알고리즘은 전체 순서에서만 올바르게 작동할 수 있습니다. 부분 순서는 위상 정렬을 사용하여 정렬할 수 있습니다.

## Monoid as Set

모나이드는 당최 단순하지만 놀라울 정도로 강력한 개념입니다. 덧셈과 곱셈의 기본 원리이기도 하죠. 모나이드는 프로그래밍에서 매우 흔하게 사용됩니다. 문자열, 리스트, 폴더블 데이터 구조, 병렬 프로그래밍의 미래, 함수형 반응형 프로그래밍의 이벤트 등 다양한 곳에서 활용됩니다.

전통적으로 모나는 이와 같은 연산이 존재하는 집합으로 정의됩니다. 이 연산은 단순히 연산의 결합 법칙을 만족해야 할 뿐만 아니라, 특별한 원소 하나가 이와 연관하여 항등원과 같은 역할을 수행해야 합니다.

For instance, natural numbers with zero form a monoid under addition. Associativity means that:

```
(a + b) + c = a + (b + c)
```

(In other words, we can skip parentheses when adding numbers.)

The neutral element is zero, because:

```
0 + a = a
```

and

```
a + 0 = a
```

두 번째 방정식은 불필요하며, 덧셈은 교환 법칙(a + b = b + a)을 따르지만, 교환 법칙은 모나이드의 정의에 포함되지 않기 때문입니다. 예를 들어, 문자열 연결은 교환 법칙을 따르지 않지만 여전히 모나이드를 형성합니다. 문자열 연결의 중립 원소는 비어 있는 문자열이며, 이 문자열을 문자열의 양쪽 끝에 추가해도 문자열을 변경하지 않습니다.

Haskell에서는 중립 원소를 mempty라고 하고 이진 연산을 mappend라고 하는 모나이드 타입 클래스를 정의할 수 있습니다.

```
class Monoid m where
    mempty  :: m
    mappend :: m -> m -> m
```

처음에는 두 개의 인자를 받는 함수, 즉 `m->m->m` 형태의 타입 시그니처가 어색해 보일 수 있습니다. 하지만 커링에 대해 이야기 나눈 후에야 그 의미가 명확해질 것입니다. 타입 시그니처에 여러 개의 화살표가 있는 경우, 두 가지 기본적인 방식으로 해석할 수 있습니다. 첫째, 가장 오른쪽에 있는 타입이 반환 타입인 여러 개의 인자를 받는 함수로 해석하는 것입니다. 둘째, 하나의 인자(가장 왼쪽에 있는 인자)를 받아 함수를 반환하는 함수로 해석하는 것입니다. 후자의 해석은 괄호를 추가함으로써 더욱 강조될 수 있습니다(괄호는 화살표 연산자가 오른쪽 연산자이기 때문에 중복되는 것이므로). 예를 들어 `m->(m->m)`와 같이 표현할 수 있습니다. 잠시 후 이 해석에 대해 더 자세히 살펴보겠습니다.

또한, 하스켈에서는 `mempty`와 `mappend`의 모나이드 속성(즉, `mempty`가 중립적이고 `mappend`가 연관적이라는 사실)을 표현할 수 없습니다. 이러한 속성이 만족되는지 확인하는 것은 프로그래머의 책임입니다.

하스켈의 클래스는 C++ 클래스처럼 강요적이지 않습니다. 새로운 타입을 정의할 때, 미리 클래스를 지정할 필요가 없습니다. 주어진 타입을 훨씬 나중에 특정 클래스의 인스턴스로 선언할 수 있습니다. 예를 들어, `mempty`와 `mappend`의 구현을 제공함으로써 `String`을 모나이드로 선언할 수 있습니다(이는 표준 Prelude에서 이미 제공되는 기능입니다).

```
instance Monoid String where
    mempty = ""
    mappend = (++)
```

여기에서는 문자열이 단순히 문자들의 목록일 뿐이라는 점을 고려하여 목록 결합 연산자(++)를 재사용했습니다.

하스켈 문법에 대해 말씀드리자면, 모든 연산자를 괄호를 사용하여 두 개의 인수로 변환할 수 있습니다. 두 개의 문자열을 결합하려면 ++를 그 사이에 삽입하면 됩니다.

```
"Hello " ++ "world!"
```

or by passing them as two arguments to the parenthesized (++):

```
(++) "Hello " "world!"
```

함수 인자들은 쉼표로 구분되지 않으며, 괄호로 묶이지 않는다는 점을 알아두시기 바랍니다. (이는 하스케일을 배우실 때 가장 어려울 수 있는 부분일 것입니다.)

또한, 하스케일은 함수 간의 동등성을 표현할 수 있다는 점을 강조하고자 합니다.

```
mappend = (++)
```

Conceptually, this is different than expressing the equality of values produced by functions, as in:

```
mappend s1 s2 = (++) s1 s2
```

이전 방식은 Hask(또는 bottoms를 무시할 경우 Set) 카테고리에서 모리즘의 동등성을 의미합니다. 이러한 방정식은 간결성을 높일 뿐만 아니라 다른 카테고리로도 일반화될 수 있습니다. 반면, extensional equality는 두 입력 문자열에 대해 mappend와 (++)의 결과가 동일하다는 사실을 나타냅니다. 함수의 값은 때때로 "점"(as in: the value of f at point x)라고 불리는데, 이를 점화(point-wise)라고 합니다. 함수의 인자를 명시하지 않고 표현된 함수 동등성은 점화(point-free)로 칭합니다. (참고로, 점화 방정식은 종종 함수의 합성으로 구성되며, 이는 "점"으로 표기되므로 초보자에게는 다소 혼란스러울 수 있습니다.)

C++에서 모나이드(monoid)를 선언하는 가장 가까운 방법은 concepts에 대한 (제안된) 구문을 사용하는 것입니다.

```
template<class T>
  T mempty = delete;

template<class T>
  T mappend(T, T) = delete;

template<class M>
  concept bool Monoid = requires (M m) {
    { mempty<M> } -> M;
    { mappend(m, m); } -> M;
  };
```

첫 번째 정의에서는 템플릿 값을 사용(제안된)합니다. 폴리모피즘 값은 각 유형에 대해 다른 값으로 구성된 값의 집합입니다.

`delete` 키워드는 기본값이 정의되지 않았음을 의미합니다. 각 경우에 따라 개별적으로 지정해야 합니다. 마찬가지로 `mappend`에 대한 기본값은 정의되지 않습니다.

`Monoid` 개념은 bool 타입으로, 주어진 유형 M에 대해 `mempty`와 `mappend`에 대한 적절한 정의가 존재하는지 테스트하는 전제(predicate)입니다.

`Monoid` 개념의 인스턴스는 적절한 특수화(specializations)와 오버로드를 제공함으로써 달성할 수 있습니다.

```
template<>
std::string mempty<std::string> = {""};

std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
}
```

## Monoid as Category

저희는 먼저 몬오이드의 일반적인 정의, 즉 집합의 원소들을 이용한 정의를 살펴보았습니다. 하지만 범주론에서는 집합과 그 원소들에서 벗어나 객체와 모피즘(morphism)에 대해 이야기하는 것이 더 효과적입니다. 

예를 들어, 5를 모든 자연수에 더하는 연산을 생각해 볼 수 있습니다. 이는 0을 5로, 1을 6으로, 2를 7로, 그리고 이와 같이 자연수 집합에 정의된 함수입니다. 이는 좋은 출발점입니다. 함수와 집합이 존재하기 때문입니다. 일반적으로 어떤 숫자 n에 대해 n을 더하는 함수는 “덧셈 함수”라고 부를 수 있습니다.

덧셈 함수들은 어떻게 결합될까요? 5를 더하는 함수와 7을 더하는 함수를 결합하면 12를 더하는 함수가 됩니다. 따라서 덧셈 함수들의 결합은 덧셈 규칙과 동일하게 만들 수 있습니다. 이것 또한 긍정적인 측면입니다. 덧셈을 함수 결합으로 대체할 수 있기 때문입니다.

하지만 잠깐만 멈춰서 생각해 봅시다. 0, 즉 중립 원소에 대한 덧셈 함수도 있습니다. 0에 더하면 아무런 이동도 일어나지 않으므로, 자연수 집합에서의 항등 함수와 같습니다.

덧셈의 전통적인 규칙을 설명하는 대신, 덧셈 함수들의 결합 규칙을 설명하는 것도 정보 손실 없이 가능합니다. 덧셈 함수들의 결합이 연관적이라는 점을 주목할 필요가 있습니다. 왜냐하면 함수 결합 역시 연관적이기 때문입니다. 또한 0, 즉 중립 원소에 대응하는 덧셈 함수도 존재합니다.

결론적으로, 범주론적 몬오이드는 단일 객체 범주입니다. “몬오이드”라는 이름은 그리스어 “모노(mono)”에서 유래했으며, 이는 “단일”을 의미합니다. 모든 몬오이드는 적절한 규칙을 따르는 모피즘의 집합을 갖는 단일 객체 범주로 설명될 수 있습니다.

문자열 연결은 특히 흥미로운 경우입니다. 오른쪽 결합자(appender)와 왼쪽 결합자(prender)를 정의할 수 있는 선택지가 있기 때문입니다. 두 모델의 결합 테이블은 서로의 거울 반전입니다. “bar”를 “foo” 뒤에 연결하는 것은 “foo”를 “bar” 뒤에 연결하는 것과 같습니다.

궁극적으로, 모든 범주론적 몬오이드(단일 객체 범주)는 고유한 집합-이진연산 몬오이드를 정의합니까? 놀랍게도, 단일 객체 범주에서 항상 집합을 추출할 수 있습니다. 이 집합은 모피즘의 집합, 즉 우리 예시에서 덧셈 함수에 해당합니다. 즉, 우리는 단일 객체 m에 대한 hom-set M(m, m)을 가집니다. 두 요소의 모니알 제품은 해당 모피즘의 결합에 해당하는 요소에 해당합니다. 만약 두 요소 f와 g를 주면, 그들의 제품은 g∘f에 해당합니다. 결합은 항상 존재합니다. 왜냐하면 이러한 모피즘의 소스와 대상은 동일한 객체이기 때문입니다. 그리고 이는 범주 규칙에 따라 항상 연관적입니다. 항등 모피즘은 이 제품의 중립 원소입니다. 따라서 범주 모니알에서 항상 몬오이드 집합을 복원할 수 있습니다. 모든 면에서 이들은 하나와 같습니다.

<!-- image -->

모나이드 홈셋을 모스함수로 그리고 집합 내의 점으로 볼 수 있습니다.

단, 수학자들에게 아주 작은 한 가지 사항이 있습니다. 모스함수는 반드시 집합을 형성할 필요는 없습니다. 범주론에서는 집합보다 더 큰 것들이 존재합니다. 두 객체 사이의 모스함수가 집합을 형성하는 범주를 ‘국소적으로 작다’고 합니다. 약속 드린 대로, 저는 이러한 미묘한 부분들을 대부분 무시할 것이지만, 기록을 위해 언급하는 것이 좋을 것 같습니다.

모나이드 홈셋의 요소들은 모스함수로서 구성 규칙을 따르며, 동시에 집합 내의 점으로서도 볼 수 있습니다. 이는 M 집합 내의 모스함수의 합성을 M(m, m) 집합 내의 모나이드 제품으로 번역합니다.

## Acknowledgments

I’d like to thank Andrew Sutton for rewriting my C++ monoid concept code according to his and Bjarne Stroustrup’s latest proposal.

## Challenges

- Generate a free category from:
    - A graph with one node and no edges
    - A graph with one node and one (directed) edge (hint: this edge can be composed with itself)
    - A graph with two nodes and a single arrow between them
    - A graph with a single node and 26 arrows marked with the letters of the alphabet: a, b, c … z.
- What kind of order is this?
    - A set of sets with the inclusion relation: A is included in B if every element of A is also an element of B.
    - C++ types with the following subtyping relation: T1 is a subtype of T2 if a pointer to T1 can be passed to a function that expects a pointer to T2 without triggering a compilation error.
- Considering that Bool is a set of two values True and False, show that it forms two (set-theoretical) monoids with respect to, respectively, operator && (AND) and || (OR).
- Represent the Bool monoid with the AND operator as a category: List the morphisms and their rules of composition.
- Represent addition modulo 3 as a monoid category.

Next: A programming example of pure functions that do logging using Kleisli categories.

53100 Siena, Siena, Italy

--- 
NotebookLM 
monoid에 대해 설명해줘

모노이드(Monoid)는 카테고리 이론과 프로그래밍에서 매우 중요하고 기본적인 대수 구조입니다. 소스들은 모노이드를 여러 관점에서 설명하고 있으며, 이는 그 개념의 단순함에도 불구하고 놀라운 활용성을 보여줍니다.

다음은 모노이드에 대한 포괄적인 설명입니다.

### 1. 전통적인 (집합론적) 모노이드 정의

가장 전통적인 정의는 **집합과 이항 연산**을 가진 대수 구조입니다. 모노이드가 되기 위해서는 다음 세 가지 요건을 만족해야 합니다:

- **집합 (Set)**: `m`이라는 집합이 있습니다.
- **이항 연산 (Binary Operation)**: `m × m → m`과 같은 이항 연산(예: `mappend` in Haskell)이 정의되어야 합니다. 이 연산은 두 개의 요소를 받아 세 번째 요소를 반환합니다. 예를 들어, 자연수의 덧셈(`+`)이나 문자열의 연결(`++`)이 될 수 있습니다.
- **항등원 (Identity Element)**: `1 → m`과 같은 특별한 요소 `e` (또는 Haskell의 `mempty`)가 집합 내에 존재해야 합니다. 이 `e`는 어떤 요소와도 연산했을 때 그 요소를 변경하지 않아야 합니다. 즉, `e + a = a` 그리고 `a + e = a`를 만족합니다. 예를 들어, 덧셈의 항등원은 0이고, 문자열 연결의 항등원은 빈 문자열입니다.
- **결합 법칙 (Associativity)**: 이항 연산은 결합 법칙을 만족해야 합니다. 즉, `(a + b) + c = a + (b + c)`와 같이 괄호 없이 연산이 가능해야 합니다.

소스에 따르면, `a + b = b + a`와 같은 **교환 법칙(commutativity)은 모노이드 정의의 일부가 아닙니다**. 예를 들어, 문자열 연결은 교환적이지 않지만 모노이드를 형성합니다.

**Haskell에서의 표현**: Haskell에서는 `Monoid` 타입 클래스를 통해 모노이드를 정의할 수 있습니다.

```
class Monoid m where
  mempty :: m           -- 항등원
  mappend :: m -> m -> m -- 이항 연산
```

예를 들어, 리스트 타입 `[a]`는 빈 리스트 `[]`를 `mempty`로, 리스트 연결 `(++)`을 `mappend`로 하는 모노이드입니다.

### 2. 카테고리로서의 모노이드 (Single-object category)

모노이드는 추상적으로 **단일 객체(single object)를 가진 카테고리**로도 설명될 수 있습니다.

- 이 관점에서는, 집합의 요소들이 단일 객체 주위의 **사상(morphisms)들**로 간주됩니다. 예를 들어, 자연수 덧셈에서 `+2`나 `+10`과 같은 "덧셈자(adders)"가 사상이 됩니다.
- 사상들의 합성은 모노이드의 이항 연산에 해당하고, 항등 사상(identity morphism)은 모노이드의 항등원에 해당합니다 (`+0`과 같은).
- 모든 사상들은 같은 객체를 원천이자 대상으로 가지므로, 항상 합성이 가능하며, 함수의 합성이 결합 법칙을 만족하므로 모노이드의 결합 법칙도 자동으로 만족됩니다.
- 소스는 이러한 두 가지 관점(집합론적 vs 카테고리적)이 **본질적으로 동일하다(one and the same)**고 설명합니다. 즉, 단일 객체 카테고리에서 사상들의 집합(hom-set)을 추출하여 그 위에서 이항 연산(합성)과 항등원(항등 사상)을 정의하면 정확히 집합론적 모노이드가 됩니다.

### 3. 자유 모노이드 (Free Monoids)

**자유 모노이드**는 주어진 생성자 집합으로부터 **최소한의 식별(identification)만을 수행**하여 구성된 모노이드를 의미합니다. 즉, 모노이드 법칙(항등원, 결합 법칙)을 유지하기 위해 필요한 최소한의 등가성만을 부여합니다.

- 예를 들어, `a`와 `b` 두 개의 생성자로 시작하면, 자유 모노이드는 `e`, `a`, `b`, `aa`, `ab`, `ba`, `bb`, `aab` 등과 같은 모든 가능한 `a`와 `b`의 리스트(또는 문자열)가 됩니다. 여기서 "곱셈"은 리스트 연결과 같습니다.
- Haskell에서 **리스트 타입 `[a]`**는 타입 `a`를 생성자 집합으로 하는 자유 모노이드에 해당합니다. 리스트 연결(`++`)은 최소한의 식별만을 수행합니다 (예: `++`은 `이 아니라`입니다).
- 자유 모노이드는 **망각 함자(forgetful functor)**의 **왼쪽 수반자(left adjoint)**로 정의됩니다. 망각 함자 `U: Mon → Set`는 모노이드의 구조(연산과 항등원)를 "잊어버리고" 그 밑에 있는 단순한 집합만을 반환합니다. 자유 함자 `F: Set → Mon`는 반대로 집합으로부터 "가장 구조가 풍부한" 모노이드를 구성합니다.

### 4. 모노이달 카테고리 내의 모노이드 (Monoid in a Monoidal Category)

더 일반적인 맥락에서, 모노이드는 **모노이달 카테고리(monoidal category) 내의 객체**로 정의될 수 있습니다.

- 모노이달 카테고리는 **텐서곱(tensor product) `⊗`** (이항 함자)과 **단위 객체(unit object) `i`**를 갖춘 카테고리이며, 이들은 결합 법칙과 항등원 법칙을 동형 사상(natural isomorphism)으로 만족합니다. 이러한 동형 사상들은 각각 **결합자(associator) `α`** (결합 법칙), **왼쪽 유니터(left unitor) `λ`**, **오른쪽 유니터(right unitor) `ρ`** (항등원 법칙)라고 불립니다.
- 이러한 모노이달 카테고리에서, 객체 `m`과 두 개의 사상 `μ :: m ⊗ m → m` (곱셈) 및 `η :: i → m` (단위)가 모노이드 법칙을 만족하면, `m`은 해당 모노이달 카테고리 내의 모노이드가 됩니다.
- 가장 유명한 예시는 **내부 함자(endofunctor) 카테고리 `[C, C]`**입니다. 여기서 텐서곱은 함자 합성(`∘`)이고, 단위 객체는 항등 함자(`I`)입니다. 이 맥락에서 정의된 모노이드가 바로 **모나드(Monad)**입니다. 즉, **"모나드는 결국 엔도함자 카테고리에서의 모노이드일 뿐이다(All told, monad is just a monoid in the category of endofunctors)."**라는 유명한 명제가 이로부터 나옵니다.

모나드 `T`는 엔도함자 `T`와 두 개의 자연 변환 `η :: I → T` (unit 또는 `return`) 및 `μ :: T ∘ T → T` (`join`)으로 구성되며, 이들이 모노이드 법칙과 동일한 모나드 법칙을 만족합니다. 또한, 모든 수반성(adjunction) `L ⊣ R`은 모나드(`R ∘ L`)를 생성합니다.

--- 

NotebookLM 
monoid가 왜 중요해?

모노이드(Monoid)는 겉보기에는 간단하지만 프로그래밍과 카테고리 이론에서 **매우 중요하고 강력한 개념**입니다. 소스에 따르면 모노이드는 기본적인 연산과 자료 구조부터 함수형 프로그래밍의 핵심 개념인 모나드에 이르기까지 광범위하게 활용됩니다.

다음은 모노이드가 중요한 몇 가지 이유입니다:

- **놀라운 단순성과 보편성 (Ubiquity and Simplicity)**
    
    - 모노이드는 "놀랍도록 단순하지만 믿을 수 없을 만큼 강력한 개념"입니다.
    - 덧셈과 곱셈 같은 기본적인 산술 연산이 모노이드를 형성합니다.
    - 프로그래밍에서 문자열, 리스트, 폴더블(foldable) 데이터 구조, 동시성 프로그래밍의 퓨처(futures), 함수형 반응형 프로그래밍의 이벤트 등 **다양한 곳에서 모노이드가 발견됩니다**.
- **합성(Composition)의 본질 추상화**
    
    - 모노이드는 결합 법칙을 만족하고 항등원(단위 요소)을 갖는 이항 연산을 통해 **합성(composition)의 본질을 추상화**합니다.
    - 예를 들어, 자연수의 덧셈에서 `+2`나 `+10`과 같은 "덧셈자(adders)"를 사상(morphisms)으로 볼 때, 이 덧셈자들의 합성이 모노이드의 이항 연산에 해당하며, `+0`는 항등원 역할을 합니다.
    - 이는 함수 합성이 결합 법칙을 만족하는 것과 유사합니다.
- **단일 객체 카테고리 (Single-Object Category)로서의 표현**
    
    - 모노이드는 **단일 객체(single object)를 가진 카테고리**로 설명될 수 있습니다.
    - 이 단일 객체 주변의 모든 사상(morphisms)들이 모노이드의 요소가 되며, 사상의 합성이 모노이드의 이항 연산이 됩니다. 항등 사상은 모노이드의 항등원에 해당합니다.
    - 소스는 이러한 전통적인 집합론적 정의와 카테고리적 정의가 "본질적으로 동일하다(one and the same)"고 강조합니다. 이는 모노이드가 매우 근본적인 대수 구조임을 시사합니다.
- **모나드(Monad)의 기반 (Foundation for Monads)**
    
    - 가장 중요한 응용 중 하나는 **모나드(Monad)의 정의**입니다. 유명한 인용구인 "**모나드는 결국 엔도함자 카테고리에서의 모노이드일 뿐이다(All told, monad is just a monoid in the category of endofunctors)**"는 모노이드가 모나드를 이해하는 데 핵심적인 개념임을 보여줍니다.
    - 모나드는 엔도함자(endofunctor) `T`와 두 개의 자연 변환 `η` (단위, `return`) 및 `μ` (`join`)으로 구성되며, 이들이 모노이드 법칙과 동일한 모나드 법칙을 만족합니다.
    - 프로그래머 관점에서 모나드는 "강력 접착 테이프(duct tape)"와 같아서 "강화된 함수(embellished functions)"를 함께 묶는 역할을 합니다. 이는 모노이드가 복잡한 프로그래밍 패턴을 구성하는 데 필수적인 추상화임을 의미합니다.
- **자유 구조 (Free Constructions)의 정의**
    
    - **자유 모노이드(Free Monoid)**는 주어진 생성자 집합으로부터 모노이드 법칙(항등원, 결합 법칙)을 유지하기 위한 **최소한의 식별(identification)만을 수행하여 구성된 모노이드**입니다.
    - 하스켈(Haskell)의 **리스트 타입 `[a]`**는 타입 `a`를 생성자로 하는 자유 모노이드에 해당합니다. 리스트 연결(`++`)은 최소한의 식별만을 수행합니다.
    - 자유 모노이드는 **잊음 함자(forgetful functor)의 왼쪽 수반자(left adjoint)로 정의**됩니다. 이는 구조를 "잊어버리는" 함자의 반대 역할을 함으로써 가장 "구조가 풍부한" 대수 구조를 생성하는 방법을 제공합니다.
    - 자유 모노이드는 연산을 실제로 수행하지 않고 "인자들을 축적"함으로써 **표현식의 생성과 평가를 분리**할 수 있게 합니다. 이는 나중에 어떤 연산을 적용할지 선택할 수 있는 유연성을 제공합니다.
- **범용 대수학(Universal Algebra) 및 이론적 중요성**
    
    - 모노이드는 다양한 대수 구조(그룹, 링 등)를 설명하는 범용 대수학의 기본 요소입니다.
    - **라베르 이론(Lawvere Theories)**은 모노이드와 같은 대수 구조의 본질을 일반화하며, 모노이드의 라베르 이론은 모든 모노이드의 범주인 `Mon`을 포함합니다. 모든 라베르 이론은 모나드를 생성하고, 모나드 대수(algebras for monads)는 라베르 이론의 모델과 동등합니다.
- **프로그래밍 언어에서의 실용적인 구현**
    
    - 하스켈에서는 `Monoid` 타입 클래스를 통해 `mempty` (항등원)와 `mappend` (이항 연산)를 정의하여 모노이드를 구현할 수 있습니다. 이는 코드 재사용성과 일반화를 촉진합니다. `String` (문자열)과 리스트(`[a]`)는 하스켈에서 모노이드의 대표적인 인스턴스입니다.

결론적으로, 모노이드는 단순한 정의에도 불구하고 **데이터의 합성과 변환, 복잡한 계산 패턴의 추상화, 그리고 카테고리 이론의 고급 개념(특히 모나드)의 이해를 위한 필수적인 토대**를 제공하기 때문에 중요합니다..