# Bartosz Milewski's Programming Cafe

Category Theory, Haskell, Concurrency, C++

October 28, 2014

## Category Theory for Programmers: The Preface

Posted by Bartosz Milewski under , , , ,

## Table of Contents

### Part One

- Category: The Essence of Composition
- Types and Functions
- Categories Great and Small
- Kleisli Categories
- Products and Coproducts
- Simple Algebraic Data Types
- Functors
- Functoriality
- Function Types
- Natural Transformations

### Part Two

- Declarative Programming
- Limits and Colimits
- Free Monoids
- Representable Functors
- The Yoneda Lemma
- Yoneda Embedding

### Part Three

- It’s All About Morphisms
- Adjunctions
- Free/Forgetful Adjunctions
- Monads: Programmer’s Definition
- Monads and Effects
- Monads Categorically
- Comonads
- F-Algebras
- Algebras for Monads
- Ends and Coends
- Kan Extensions
- Enriched Categories
- Topoi
- Lawvere Theories
- Monads, Monoids, and Categories

There is a free pdf version of this book with nicer typesetting available for download. You may order a hard-cover version with color illustrations at Blurb. Or you may watch me teaching this material to a live audience.

# Preface

몇 가지 아이디어를 꾸준히 탐색해 왔습니다. 프로그래머를 대상으로 하는 범주론에 관한 책을 쓰겠다는 생각을 해왔는데요. 컴퓨터 과학자가 아니라, 엔지니어라는 점을 분명히 말씀드립니다. 저는 과학과 엔지니어링 사이의 간극에 대한 깊은 이해를 가지고 있습니다. 하지만 저는 항상 복잡한 것을 설명하고 싶다는 강한 동기를 가지고 왔습니다. 리처드 파인먼과 같이 단순한 설명에 능통한 사람에게 깊은 존경심을 가지고 있습니다. 제가 파인먼만큼 뛰어나지는 않겠지만, 최선을 다해 보겠습니다. 먼저 독자분들이 범주론을 배우도록 동기를 부여하기 위해 이 서론을 게시함으로써 논의를 시작하고 피드백을 구하고자 합니다.

이 서론을 통해 이 책이 바로 당신을 위한 책이며, 한 가지 가장 추상적인 수학 분야를 ‘여유 시간에’ 배우는 데 대한 모든 의심은 근본적으로 정당하지 않다는 것을 설득하고자 합니다.

저의 낙관적인 시각은 여러 관찰에 기반합니다. 첫째, 범주론은 매우 유용한 프로그래밍 아이디어의 보고입니다. 하스켈 프로그래머들은 오랫동안 이 자원을 활용해 왔고, 그 아이디어들이 다른 언어로 서서히 확산되고 있지만, 이 과정은 너무 느립니다. 우리는 이 과정을 가속화해야 합니다.

둘째, 다양한 수학 분야가 존재하며, 각 분야는 서로 다른 독자층에게 어필합니다. 당신이 미적분이나 대수학에 알레르기가 있을 수는 있지만, 그것이 범주론을 즐기지 못한다는 의미는 아닙니다. 오히려 범주론은 프로그래머의 정신에게 특히 적합한 종류의 수학이라고 강력하게 주장하고 싶습니다. 왜냐하면 범주론은 구체적인 내용보다는 구조 자체를 다루기 때문입니다. 프로그램이 구성 가능한 구조를 만드는 바로 그 종류의 구조를 다루는 것입니다.

구성(composition)은 범주론의 근본적인 부분이며, 범주 자체의 정의에도 포함됩니다. 저는 구성이 프로그래밍의 핵심이라는 점을 강력하게 주장하고자 합니다. 우리는 어떤 것을 구성하는 것과 관련된 개념을 오랫동안 사용해 왔으며, 뛰어난 엔지니어가 서브루틴이라는 아이디어를 생각해 낸 이전에는 훨씬 오래되었습니다. 구조화 프로그래밍의 원리는 코드 블록을 구성 가능하게 만들어 프로그래밍을 혁신했으며, 객체 지향 프로그래밍은 객체들을 구성하는 것에 관한 것이고, 함수와 대수적 데이터 구조를 구성함으로써 동시성을 구성하는 것은 다른 프로그래밍 패러다임으로는 거의 불가능합니다.

세 번째로, 제가 가진 비밀 무기가 있습니다. 바로 수학을 좀 더 프로그래머들에게 친근하게 다가갈 수 있도록, 쇠 자를 사용하여 뼈대를 깎는 것과 같은 방식으로 다듬는 것입니다. 전문 수학자로서, 여러분은 모든 가정에 신중해야 하고, 각 문장을 정확하게 명시해야 하며, 모든 증명을 엄격하게 구성해야 합니다. 이러한 점들 때문에 수학 논문이나 책은 일반인 독자에게는 매우 어렵게 느껴질 수 있습니다. 저는 원래 물리학을 전공했었는데, 물리학에서는 비형식적인 추론을 통해 놀라운 발전을 이룩했습니다. 대단한 물리학자 P. A. M. 다이랙이 특정 미분 방정식을 해결하기 위해 즉석에서 만들어낸 다이랙 델타 함수를 수학자들이 처음에는 비웃었지만, 이후 완전히 새로운 계산 이론인 분포 이론이 다이랙의 통찰력을 공식화하면서 그 가치를 인정하게 되었습니다.

물론 손짓으로 논쟁을 펼칠 경우 명백히 틀린 주장을 하게 될 위험이 있으니, 이 책에서는 비공식적인 논거에 대한 견고한 수학적 이론적 기반을 마련하도록 노력하겠습니다. 제 책상 옆에는 Saunders Mac Lane의 ‘Category Theory for the Working Mathematician’이라는 닳아빠진 고서를 항상 두고 있습니다.

이 강의는 프로그래머를 위한 범주론이므로, 주요 개념들을 컴퓨터 코드를 통해 자세히 설명드리겠습니다. 아마도 함수형 언어가 더 대중적인 명령형 언어보다 수학에 더 가깝다는 것을 이미 알고 계실 겁니다. 또한, 더 높은 수준의 추상화를 제공합니다. 따라서 다음과 같이 말씀드리고 싶을 수도 있습니다: “해스켈을 먼저 배우셔야 범주론의 풍요로움을 누리실 수 있습니다.” 하지만 이는 범주론이 함수형 프로그래밍 외에는 아무런 응용이 없다는 것을 의미하며, 이는 사실이 아닙니다. 그래서 저는 많은 C++ 예제를 제공해 드리겠습니다. 물론, 다소 불편한 문법을 극복해야 하고, 패턴이 지나치게 눈에 띄지 않을 수도 있으며, 더 높은 수준의 추상화를 위해 복사 붙여넣기를 해야 할 수도 있습니다. 하지만 그것은 C++ 프로그래머의 한계일 뿐입니다.

하지만 하스케일 문제는 해결되지 않았습니다. 하스케일 프로그래머가 되어야 하는 것은 아니지만, C++로 구현될 아이디어를 스케치하고 문서화하기 위한 언어로 활용해야 합니다. 제가 하스케일로 시작하게 된 방식과도 완전히 일치합니다. 간결한 문법과 강력한 타입 시스템이 C++ 템플릿, 데이터 구조, 알고리즘을 이해하고 구현하는 데 큰 도움이 되었습니다. 다만, 독자 여러분께서 하스케일을 이미 알고 계시다고 기대하기는 어렵습니다. 따라서, 제가 진행하면서 천천히 하스케일을 소개하고, 한 번에 모든 내용을 설명드리겠습니다.

경험이 풍부한 프로그래머님께서는 다음과 같은 질문을 던지실 수도 있습니다. “오랫동안 카테고리 이론이나 함수형 프로그래밍 기법에 신경 쓰지 않았는데, 이제 와서 이런 변화가 생기는군요. 분명 C++의 람다 표현식과 같은 함수형 개념이 객체 지향 프로그래밍의 대명자인 자바에도 침투하기 시작했다는 것을 느끼셨을 겁니다. 최근 몇 년마다 새로운 표준이 출시되는 등, 변화하는 세상에 발맞추기 위해 빠르게 진화하고 있습니다. 이러한 모든 활동은 결국 물이 끓기 시작할 때와 같습니다. 이제 물고기를 끓는 물속에서 계속 헤엄치느냐, 아니면 다른 대안을 찾아보느냐를 결정해야 하는 상황인 것입니다.”

저희는 다중 코어 컴퓨팅의 혁명이 큰 변화를 이끄는 주요 요인 중 하나입니다. 객체 지향 프로그래밍이라는 기존의 프로그래밍 방식은 동시성 및 병렬 처리 측면에서 특별한 이점을 제공하지 않으며, 오히려 위험하고 불안정한 설계로 이어질 수 있습니다. 객체 지향의 기본 원리인 데이터 은닉이 공유 및 변수 변경과 결합될 경우, 데이터 레이스 발생 가능성이 높아집니다. 보호하는 데이터와 함께 뮤텍스를 사용하는 것은 좋지만, 불행히도 잠금은 상호 작용하지 않으며, 잠금 은닉은 데드락 발생 가능성을 더욱 높이고 디버깅을 더욱 어렵게 만들 수 있습니다.

물론, 동시성(concurrency)이 없는 경우에도 소프트웨어 시스템의 복잡성이 명령형(imperative) 패러다임의 확장성 한계를 시험하고 있습니다. 쉽게 말해, 부작용(side effects)이 심각해지고 있습니다. 물론, 부작용을 가진 함수는 종종 편리하고 작성하기 쉽습니다. 이러한 함수의 효과는 함수의 이름과 주석에 의해 원칙적으로 코딩될 수 있습니다. SetPassword 또는 WriteFile과 같이 부작용을 일으키는 함수는 분명히 상태를 변경하고 부작용을 생성하며, 우리는 이러한 점을 잘 알고 있습니다. 문제는 부작용을 가진 함수를 다른 부작용을 가진 함수 위에 덧붙여 구성할 때 발생하는 것입니다. 부작용 자체가 나쁜 것은 아니지만, 그 효과가 눈에 보이지 않아 더 큰 규모에서 관리하기가 어렵다는 점이 문제입니다. 부작용은 확장되지 않으며, 명령형 프로그래밍은 부작용에 기반합니다.

하드웨어 변화와 소프트웨어 복잡성 증가로 인해 프로그래밍의 근본적인 토대를 재고해야 하는 상황에 놓여 있습니다. 유럽의 웅장한 고딕 양식 성당을 건설했던 건축가들처럼, 저희는 재료와 구조의 한계를 극복하기 위해 끊임없이 기술을 연마해 왔습니다. 프랑스 부아브이사의 미완성 고딕 양식 성당은 이러한 인간의 한계에 대한 깊은 고뇌를 보여주는 증거입니다. 이전의 모든 성당보다 높고 가벼운 건축을 목표로 했지만, 연쇄적인 붕괴를 겪었습니다. 철골과 목재 지지대와 같은 임시 조치로 인해 붕괴를 막고 있지만, 분명히 많은 문제들이 발생했습니다. 현대적인 재료 과학, 컴퓨터 모델링, 유한 요소 해석, 그리고 일반적인 수학 및 물리학의 도움 없이 이렇게 많은 고딕 건축물이 성공적으로 완공된 것은 경이로운 일입니다. 미래 세대 역시 복잡한 운영체제, 웹 서버, 인터넷 인프라를 구축하는 데 보여주신 저희의 프로그래밍 기술에 깊이 감탄하시길 바랍니다. 그리고 솔직히 말씀드리면, 저희가 이러한 기반 위에서 모든 것을 구축했기 때문에, 미래에는 이러한 기반을 강화해야만 앞으로 나아갈 수 있습니다.

<!-- image -->

Ad hoc measures preventing the Beauvais cathedral from collapsing

Next: Category: The Essence of Composition.

